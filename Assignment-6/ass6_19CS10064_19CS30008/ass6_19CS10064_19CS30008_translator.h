/**
* Vanshita Garg | 19CS10064
* Ashutosh Kumar Singh | 19CS30008
* Compilers Laboratory
* Assignment 6
*
* Header file for translation
*/

#ifndef __TRANSLATOR_H
#define __TRANSLATOR_H

#include <iostream>
#include <vector>
#include <list>
#include <map>
using namespace std;

/*
    Sizes for basic data types, according to x86_64 architecture.
    To target a different platform, the sizes can be changed here itself.

    List of sizes
    -------------
    void        0 bytes
    function    0 bytes
    char        1 byte
    int         4 bytes
    pointer     8 bytes
    float       8 bytes

*/

#define __VOID_SIZE 0
#define __FUNCTION_SIZE 0
#define __CHARACTER_SIZE 1
#define __INTEGER_SIZE 4
#define __POINTER_SIZE 8
#define __FLOAT_SIZE 8

typedef enum {
    VOID,
    BOOL,
    CHAR,
    INT,
    FLOAT,
    ARRAY,
    POINTER,
    FUNCTION
} DataType;


typedef enum  {
    // DEFAULT, 
    ADD, SUB, MULT, DIV, MOD, SL, SR, 
    // LT, GT, EQ, NEQ, LTE, GTE, LOG_AND, LOG_OR, 
    BW_AND, BW_OR, BW_XOR, 
    BW_U_NOT ,U_PLUS, U_MINUS, REFERENCE, DEREFERENCE, U_NEG, 
    GOTO_EQ, GOTO_NEQ, GOTO_GT, GOTO_GTE, GOTO_LT, GOTO_LTE, IF_GOTO, IF_FALSE_GOTO, 
    CtoI, ItoC, FtoI, ItoF, FtoC ,CtoF, 
    ASSIGN, GOTO, RETURN, PARAM, CALL, ARR_IDX_ARG, ARR_IDX_RES, FUNC_BEG, FUNC_END, L_DEREF
} opcode;


class symbol;
class symbolType;
class symbolValue;
class symbolTable;

class quad;
class quadArray;


/*
    External variables and methods generated by bison
*/
extern char* yytext;
extern int yyparse();

extern int nextinstr;

class symbolType {
public:
    int pointers;
    DataType type;
    DataType nextType;
    vector<int> dims;
};


class symbolValue {
public:
    int i;
    char c;
    float f;
    void* p;

    void setInitVal(int i);
    void setInitVal(char c);
    void setInitVal(float f);
};


class symbol {
public:
    string name;
    symbolType type;
    symbolValue* initVal;
    int size;
    int offset;
    symbolTable* nestedTable;

    symbol();
};


class symbolTable {
public:
    map<string, symbol*> table;
    vector<symbol*> symbols;
    int offset;
    static int tempCount;

    symbolTable();
    symbol* lookup(string name, DataType t = INT, int pc = 0);
    symbol* searchGlobal(string name);
    string gentemp(DataType t = INT);

    void print(string tableName);
};


class quad {
public:
    opcode op;
    string arg1;
    string arg2;
    string result;

    quad(string, string, string, opcode);

    string print();
};


class quadArray {
public:
    vector<quad> quads;

    void print();
};


class param {
public:
    string name;
    symbolType type;
};


class expression {
public:
    int instr;
    DataType type;
    string loc;
    list<int> truelist;
    list<int> falselist;
    list<int> nextlist;
    int fold;
    string* folder;

    expression();
};


class declaration {
public:
    string name;
    int pointers;
    DataType type;
    DataType nextType;
    vector<int> li;
    expression* initVal;
    int pc;
};



/*
    An overloaded method to add a (newly generated) quad of the form: result = arg1 op arg2 where op usually is a binary operator. 
    If arg2 is missing, op is unary. If op also is missing, this is a copy instruction.
    It is overloaded for different types of quads (int, float or string)
*/
void emit(string result, string arg1, string arg2, opcode op);
void emit(string result, int constant, opcode op);
void emit(string result, char constant, opcode op);
void emit(string result, float constant, opcode op);


/*
    A global function to create a new list containing only i, an index into the array of quads, 
    and to return a pointer to the newly created list
*/
list<int> makelist(int i);

/*
    A global function to concatenate two lists list1 and list2 and to return a pointer to the concatenated list
*/
list<int> merge(list<int> &list1, list<int> &list2);

/*
    A global function to insert address as the target label for each of the quads on the list l
*/
void backpatch(list<int> l, int address);


// bool typecheck(symbol* &s1, symbol* &s2);
// bool typecheck(symbolType* t1, symbolType* t2);

/*
    Converts a symbol of one type to another and returns a pointer to the converted symbol
*/
void convertToType(expression* arg, expression* res, DataType toType);

void convertToType(string t, DataType to, string f, DataType from);

/*
    Converts an int to a bool and adds required attributes
*/
void convertIntToBool(expression* expr);

/*
    Converts a bool to an int and adds required attributes
*/
// expression* convertBoolToInt(expression* expr);

/*
    Auxiliary function to get the size of a type
*/
int sizeOfType(DataType t);

/*
    Auxilary function to print a type
*/
string checkType(symbolType* t);

string getInitVal(symbol* sym);

#endif